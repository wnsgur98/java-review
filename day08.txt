day08

* QR 체크하기
* 과제 제출 안한사람 과제 제출하기
	- 주말 과제 제출 안한 사람들 끝나고 남아서 완성 후 제출해야함
		1) 멘토씨리즈 (~p142) 예제 코드 작성 및 코드해석 제출
		2) 지난주 평일 과제 제출
--------------------------------------------------------------
복습(과제) -> 2차원 배열 -> 메소드

0. 복습
입력메소드
	Scanner 클래스 => import
	Scanner sc = new Scanner(System.in);

	.nextInt()
	.nextDouble()
	.next()
	.nextLine()
	.close()
	
new
	heap 메모리, 시작주소값을 가져온다

출력메소드
	.print()
	.println()
	.printf()

	%d	%s	%c	%f
	  
연산자
	최단산쉬관리삼대
	int num = 0;
	++num;		num => 1
			num => 1	  

배열
1) 선언과 생성
	//어떤 값을 넣을지는 모르나 몇 칸을 만들지 알 때
	자료형[] 배열명 = new 자료형[배열크기];	

	//어떤 값을 넣을 지 알 때
	자료형[] 배열명 = {값1, 값2, ..};

	//배열의 선언과 생성이 다를 때
	자료형[] 배열명;
	배열명 = new 자료형[]{값1, 값2, ...};

	//어떤 값이 들어갈 지도 모르고 몇칸일지도 모를 때
	자료형[] 배열명 = null;
--------------------------------------------------------------------------	
1. 2차원 배열
1) 2차원 배열의 선언과 생성
	자료형[][] 배열명 = new 자료형[행][열];
	자료형[][] 배열명 = {{값1, 값2, 값3}, {값1, 값2, 값3}};


	1	2	3	4
	5	6	7	8
	9	10	11	12

	=> 3행 4열

2) 2차원 배열 길이
	배열명.length : 행의 길이
	배열명[i].length : 열의 길이

3) for-each문(빠른 for문, 확장 for문)
	//1차원
	for(자료형 변수명 : 배열명){
		실행할문장;
	}

	//2차원
	for(자료형[] 변수명1 : 배열명){
		for(자료형 변수명2 : 변수명1){
			실행할문장;
		}
	}

2. 배열의 정렬
1) 정렬 알고리즘
	삽입정렬	각 요소를 이미 정렬된 부분에 삽입
	선택정렬	배열의 최소값을 찾아 첫위치로 이동
	버블정렬	인접한 두요소를 비교하고 교환하며 가장 큰 값을 뒤로 이동

2) 삽입 정렬(Insertion Sort)
	배열의 요소를 하나씩 순회하며 정렬된 부분에 올바른 위치를 찾아 삽입하는 방식

+) 동작방식
	두번째 요소부터 시작하여 이전 요소들과 비교한다
	비교를 통해 자신의 위치를 찾은 후 그 자리에 삽입한다
	나머지 요소를 반복적으로 처리한다


3) 선택정렬(Selection Sort)
	배열에서 가장 작은 값을 선택하여 현재 위치와 교환하는 방식

+) 동작원리
	배열에서 가장 작은 값을 찾아 현재 위치로 이동한다
	다음위치에서 가장 작은 값을 찾아 이동한다
	마지막까지 반복한다

4) 버블정렬
	인접한 두 요소를 비교하여 교환하는 방식
	가장 큰값이 단계별의 끝으로 이동한다

+) 동작원리
	반복적으로 배열을 순회하며 인접한 두 요소를 비교한다
	두 요소의 순서가 잘못되었다면 교환(swap)한다
	각 반복이 끝날 때 가장 큰 요소는 배열의 끝으로 이동하여 정렬된 상태가 된다
	마지막 정렬된 요소를 제외하고 나머지 요소를 비교하고 정렬한다
	배열이 완전히 정렬될 때까지 이 과정을 반복한다

	[5, 2, 9, 1, 6]
	
첫번째 순회 : 5와 2 비교 -> 5 > 2 교환	=> [2, 5, 9, 1, 6]	
	    5와 9 비교 -> 5 < 9 교환 없음
	    9와 1 비교 -> 9 > 1 교환	=> [2, 5, 1, 9, 6]
	   9와 6 비교 -> 9 > 6  교환	=> [2, 5, 1, 6, 9]

두번째 순회 : 2와 5 비교 -> 교환 없음
	    5와 1 비교 -> 5 > 1	교환	=> [2, 1, 5, 6, 9]
	   5와 6 비교 -> 교환 없음		=> [2, 1, 5, 6, 9]

세번째 순회 : 2와 1 비교 → 2 > 1  교환	=> [1, 2, 5, 6, 9]
2와 5 비교 → 2 < 5 → 교환 없음  		=> [1, 2, 5, 6, 9]
결과: [1, 2, 5, 6, 9]
가장 큰 값 5가 배열의 끝에서 세 번째 위치로 이동

4번째 순회 (이미 정렬됨, 더 이상 비교할 필요 없음)
최종 결과 : [1, 2, 5, 6, 9]
	

5) Arrays.sort()
	java.util.Array 클래스에 포함된 정렬 메소드
	내부적으로 TimSort 알고리즘을 사용하며 합병정렬과 삽입정렬을 결합한 고효율 알고리즘이다
	기본적으로 오름차순으로 정렬되며 배열을 빠르고 효율적으로 정렬할 수 있다

  Arrays.toString(배열명)
	.toString() 배열의 내용을 문자열 형식으로 반환하는 메소드
	배열을 보기 쉽게 출력하기 위해 사용한다
	기본적으로 1차원 배열의 내용을 출력할 수 있다

  Arrays.deepToString(배열명)
	다차원 배열의 내용을 출력하기 위해 사용한다

3. 배열의 얕은 복사와 깊은 복사
	복사가 참조를 복사하는지 또는 실제 데이터를 복사하는지에 따라 얕은 복사와 깊은 복사로 나눌 수 있다

1) 얕은 복사(Shallow Copy)
	복사된 객체가 원복 객체의 참조를 공유한다
	원본과 복사본이 같은 객체를 참조하므로, 하나를 수정하면 다른 하나에도 영향을 미친다
	배열의 경우 복사가 이루어져도 내부 요소는 복사되지 않고 참조값만 복사된다
	
2) 깊은 복사(Deep Copy)
	원본 객체의 데이터 자체를 복사하여 복사된 객체가 원본 객체와 독립적이다
	원본 객체를 수정해도 복사본은 영향을 받지 않는다
	배열의 경우 내부 요소를 재귀적으로 복사해야한다

+) 재귀(Recursion)	
	함수가 자기자신을 호출하는 프로그래밍 기법이다
	큰 문제를 해결하기 위해 동일한 문제를 더 작은 크기로 나누고 반복적으로 해결하는 방식으로 작동한다
---------------------------------------------------------------------
1차 면담
12/2/월
14:50~15:00	김태현
15:50~16:00	박우열
17:00~17:10	조은혜
17:10~17:20	박수현
17:20~17:30	오현택
17:50~18:00	이승아
18:00~18:10	길진수

12/3/화
09:50~10:00	강후현
10:50~11:00	황어진
12:50~12:00	윤지수
14:50~15:00	김은혜
15:50~15:00	조성현
17:10~17:20	김승현
17:20~17:30	

12/4/수
09:50~10:00	송명진
10:50~11:00	고현섭
12:50~12:00	배지수
14:50~15:00	허준혁
15:50~15:00	문준혁
17:10~17:20	임초현
17:20~17:30	이정민

12/5/목
09:50~10:00	노형우
10:50~11:00	박승우
12:50~12:00	신동석

---------------------------------------------------------------------
+) 복습
1) 배열	: 하나의 타입으로 된 여러가지 값을 저장할 수 있다
2) 배열의 사용 목적
	- 데이터의 집합을 효율적으로 관리하기 위한 목적
		동일한 데이터 타입을 가진 여러개의 값을 하나의 변수에 저장하고 관리할 수 있어서
		데이터 집합을 효율적으로 처리할 수 있다
	- 데이터의 순서를 보존하기 위한 목적
		선형적인 데이터 구조로, 데이터의 순서를 보존하면 쉽게 접근할 수 있는 방법 제공
		index
	- 반복문을 사용하여 배열의 요소를 처리하기 위한 목적
		많은 양의 데이터를 일괄적으로 처리할 수 있는 반복문을 쉽게 사용할 수 있어서
		데이터 처리를 효율적으로 할 수 있다
	- 메모리를 효율적으로 사용하기 위한 목적
	- 데이터를 정렬하거나 검색하기 위한 목적
		데이터를 정렬하거나 검색하는 데 사용될 수 있어서 프로그래밍에서 매우 중요한 자료구조이다

3) 배열의 선언
	int[] 배열명;	int 배열명[];
	
4) 배열의 생성과 초기화
	new를 사용한다	배열명 = new 자료형[칸수];
	값을 대입한다	배열명 = {값, 값, 값, ..};
	null을 사용한다	값도 모르고, 칸수도 아직 모를 때 사용한다

5) 다차원 배열의 선언과 생성
	배열안에 또 다른 배열이 포함된 형태, 차원수와 각 차원의 크기를 지정
	자료형[][] 배열명 = new 자료형[행][열];
	자료형[][] 배열명 = {{값, 값}, {값, 값}};


	int[][] arr = {{1}, {2, 3}, {4, 5, 6}};
	System.out.println(arr);
	System.out.println(arr.length);
	System.out.println(arr[0].length);
	System.out.println(arr[1].length);
	System.out.println(arr[2].length);
	for(int[] ar : arr) {
		for(int ar1 : ar) {
			System.out.print("* ");
		}
		System.out.println();
	}

6) 배열의 구조

	int[]		ar		=	new	int[3];
		-----------------		-----------------------
		참조변수 Stack영역			참조값 Heap영역
		[첫번째 주소값]		= 	[값1][값2][값3];
		    ar				 0    1    2

	자바 배열은 C나 C++과 달리 포인터 연산을 허용하지 않는다
	따라서 배열 요소에 접근할 때는 인덱스 연산을 통해 요소에 접근해야한다
	인덱스 연산을 통해 배열 요소에 접근할 때는 배열변수의 시작주소와 인덱스 번호를 더한 값이 
	해당 요소의 주소가 된다
	배열변수는 호출스택에 할당되며 배열변수에 저장한 값은 배열의 시작주소를 나타낸다

	배열 요소는 Heap메모리에 할당되므로 배열 변수가 참조하는 Heap메모리 위치를 가리키는
	참조(reference) 변수를 스택(Stack)메모리에 저장하는 것이다

7) for-each문
	코드의 가독성을 높이고 반복문에서 발생할 수 있는 일부 에러를 방지할 수 있는 장점이 있다
	for(변수 타입 변수명:배열){
		//반복실행할 코드;
	}

---------------------------------------------------------------------------------
4. 메소드(Method)
0) 함수와 메소드
	클래스 밖에 선언되어 있다면 함수라고 부르지만 클래스 내부에 선언되어 있는 함수는 메소드라고 부른다
	자바에서는 모든 함수가 클래스 내부에 선언되기 때문에 메소드만 존재한다
	
1) 메소드
	기능이다
	이름뒤에 소괄호
	단, 키워드 뒤에 소괄호는 메소드가 아니다
	main()		=> 메인메소드
	println()	=> 출력메소드
	next()		=> 입력메소드
	for()		=> for문(반복문)

2) 메소드 선언과 구현(정의)
	리턴타입 메소드명(자료형 매개변수, ...)		<- 선언부
	{					<- 구현부
		실행할문장;
		return 리턴값;
	}

- 리턴타입 : 반환할 값이 있다면 반환값의 자료형을 작성한다. 없다면 void로 작성한다.
- 메소드명 : 동사로 작성한다. 해당 기능을 알기 쉽도록 작성한다.
- 매개변수 : 외부에서 전달받을 값이 있다면 자료형과 순서에 맞게 선언해준다(자료형이 반드시 필요하다)
	생략이 가능하다(단, 생략하면 외부에서 값을 받을 수 없다)
- 실행할 문장 : 생략이 가능하다. 메소드의 기능을 구현하는 코드를 작성한다
- return : 생략이 가능하며, return이 실행되면 메소드가 종료된다.
	return값이 있다면 메소드를 사용한 부분을 통채로 리턴값으로 본다.
	return값이 없다면 값이 아니다.
- 선언부 : 메소드의 기능을 정의ㅏ는 문장, 메소드에서 호출할 떄 필요한 내용을 가지고 있다 메소드명은 동사로
- 구현부

3) 메소드의 정의와 사용
	메소드를 정의할 때는 {}중괄호가 있고, 반드시 메소드 밖에서 정의한다
	메소드를 사용할 때는 {}중괄호가 없고, 반드시 메소드 안에서 사용한다

4) 메소드의 정의 순서 ★★★★★
	리턴타입 메소드명(자료형 매개변수, ...)		<- 선언부
	{					<- 구현부
		실행할문장;
		return 리턴값;}
(1) 기능을 생각한다(숫자를 더해주는 기능)
(2) 리턴타입(반환타입)을 생각한다. 생각이 나지 않는다면 우선 void로 작성한다
	void
(3) 기능에 알맞은 메소드명을 작성한다(add, sum, plus, pringAdd...)
	void add
(4) 매개변수를 생각한다
	void add(int num1, int num2)	* 매개변수는 각각 적어야 한다 ex) int num1, num2 => X
	{							    int num1, int num2 => O

	}
(5) 실행할 문장을 작성한다(구현부)
	void add(int num1, int num2)
	{
		int result = num1 + num2;
	}

(6) 리턴값을 생각한다.
	int add(int num1, int num2)
	{
		int result = num1 + num2;
		return result;
	}

5) 메소드의 호출 방법 4가지 ★★★★★
	매개변수	리턴값	호출
	x	x	객체명.메소드명();
	o	x	.메소드명(인수);	//매개변수의 개수만큼 인수 전달
	x	o	syso(.메소드명());	변수 = 객체명.메소드명();
	o	o	syso(객체명.메소드명(인수));	변수 = 객체명.메소드명(인수);







* 실습코드 작성후 메모장에 task08_본인이름으로 전달
* 로직구성 필수!!

17:50~18:00	오현택
18:00~18:10	이승아
18:10~18:20	길진수
18:20~18:30	윤지수

※ 주말 과제 멘토씨리즈 제출 안한사람은 제출 후 집에 가야함!!
※ 코드 작성이 다 안되었어도 task08_이름.txt 카톡 보내기!!

- 주말 과제 제출자 : 신동석, 길진수, 김은혜, 조은혜, 임초현, 배지수, 황어진, 오현택, 박수현
- 멘토씨리즈 제출 필요












