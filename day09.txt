day09
복습 -> 메소드2 -> 클래스1

0.복습
1) 배열의 사용 목적
	- 데이터 정렬, 검색하기 위함
	- 데이터 집합을 효율적으로 관리하기 위함
	- 메모리를 효율적으로 사용하기 위함
	- 데이터의 순서를 보존하기 위함
	- 반복문을 사용하여 배열의 요소를 처리하기 위함

2) 배열
	변수 : 하나의 자료형으로 하나의 값 저장공간
	배열 : 하나의 자료형으로 여러가지 값 저장공간

3)배열의 선언과 생성	
	//칸수만 알고 있을 때
	자료형[] 배열명 = new 자료형[크기(칸수)];

	//값을 알고 있을 때
	자료형[] 배열명 = {값, 값, 값,...};

	//값을 모르고 나중에 생성할 때
	자료형[] 배열명;
	배열명 = new 자료형[]{값, 값, 값,...};
	
	//배열변수만 선언할 때
	자료형[] 배열명 = null;

	null : 주소값을 모를 때 사용한다
	new : heap 메모리에 배열을 생성하고 시작주소값을 담고있다

4) 배열의 구조
	int[]		ar	=	new	int[3]

		----------------	-------------------
		stack 메모리,참조변수	heap 메모리,참조값
		[시작주소=참조값]		[0][0][0]
					 0  1  2	

5) 2차원 배열 선언과 생성
	//칸(행과 열)을 알고 있을 때
	자료형[][] 배열명 = new 자료형[행][열];	*열은 생량해도 가능

	//값을 알고 있을 때
	자료형[][] 배열명 = {{값,값},{값,값}}	* 하나하나는 행이고 전체는 열
	자료형[][] 배열명 = {{값},{값,값},{값,값,값}}

6) 반복문과 배열
	1차원 배열 => int[] ar = {1, 2, 3, 4};
	syso(ar);	//참조값
	for(int i = 0; i < ar.length; i++){
		syso(ar[i]);
	}

	for(int data : ar){
		syso(data);
	}

	//2차원배열 => int[][]	ar = {{1, 2}, {3, 4},{5, 6}};
	
	for)int[] i : ar2){
		for(int data : i){
			syso(data);
		}
	}

 	  for(int i = 0; i < ar2.length; i++){
      for(int j = 0; j < ar2[i].length; j++){
         syso(ar2[i][j]);
      }
   }

7) 메소드
	기능
	어떠한 기능을 하는 코드들의 묶음
	이름뒤에 소괄호
	
	함수 : 클래스 외부에 선언되어 있는 것
	메소드 : 클래스 내부에 선언되어 있는 것

8) 메소드의 정의
	리턴타입 메소드명(자료형 매개변수)	<- 선언부
	{
		실행할 문장;		<- 구현부
		return 리턴값;
	}

9) 메소드 호출방법
   매개변수    리턴값   		메소드 정의                  		   메소드호출
   x   		x           void 메소드명(){}               			객체명.메소드명();
   o   		o    리턴타입 메소드명(자료형 매개변수){return 매개변수}   	syso(객체명.메소드명(인수));                                   리턴타입 변수 = 객체명.메소드명(인수);
   o   		x    void 메소드명(자료형 매개변수){}         		       객체명.메소드명(인수);
   x   		o    리턴타입 메소드명(){ return 매개변수 }         		syso(객체명.메소드명());

10) 메소드 정의와 사용
   정의 {}중괄호가 있고 반드시 메소드 밖에서 정의한다
   사용 {}중괄호가 없고 반드시 메소드 안에서 정의한다

11) 메소드 정의 순서
   리턴타입 메소드명(자료형 매개변수, ..)   <- 선언부
   {            <- 구현부 
      실행할문장;
      return 리턴값;
   }

- 기능을 생각한다(두개의 값을 더하는 기능)
- 리턴타입을 생각한다. 생각나지 않으면 void로 작성한다
   void
- 기능에 맞는 메소드명을 작성한다(동사로 작성한다)
   void add
- 매개변수를 생각한다
   void add(int num1, int num2)   <- 선언부
   { }            <- 구현부
- 실행할문장을 작성한다(구현부)
   void add(int num1, int num2)
   {
      syso("num1 = " + num1 + ", num2 = " + num2);
      int result = num1 + num2;
   }
- 리턴값을 생각한다
   void add(int num1, int num2)
   {
      syso("num1 = " + num1 + ", num2 = " + num2);
      int result = num1 + num2;
      return result;
   }
- 리턴값이 있으면 리턴값에 맞게 리턴타입을 변경한다
   int add(int num1, int num2)
   {
      syso("num1 = " + num1 + ", num2 = " + num2);
      int result = num1 + num2;
      return result;
   }
매개변수 x 리턴값 x => 메소드명();
매개변수 x 리턴값 o => syso(메소드명());
매개변수 o 리턴값 x   => 메소드명(인수);
매개변수 o 리턴값 o => syso(메소드명(인수));

-----------------------------------------------------------------------------------------------
1. 메소드
1) 메소드와 메모리
	메소드는 실행되면 메모리의 stack영역에 메소드 실행에 필요한 저장공간이 생성된다
	그 곳에 메소드 내부에서 선언한 변수(지역변수, 매개변수)들의 저장공간이 생성된다
	메소드의 코드가 모두 실행되어 종료되면 stack 영역에서 해당 메소드의 저장공간이 삭제된다(메모리 헤제)
	그러면 지역변수의 저장공간이 사라지므로 지역변수는 사용이 불가능하다 

+) 스택 프레임의 장점
	메모리 관리 효율성 : 메소드를 호출 할 때 필요한 메모리를 동적으로 할당하고, 호출이 끝나면 자동으로 해제한다
	재귀적 호출 지원 : 재귀 호출에 각 호출마다 독립적인 스택 프레임이 생성되어, 서로 간섭없이 수행된다
	지역성 : 스택 메모리 접근 속도가 빠르며, 지역변수와 매개변수는 메모리 접근 비용이 적다

2) 인수와 매개변수
	인수(Argument) : 메소드를 사용할 때 메소드의 매개변수로 전달될 값
	매개변수(parameter) : 외부에서 전달받아 값을 저장하고 메소드내에서 사용될 변수

	- 메소드의 인수와 매개변수는 반드시 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다
	- return되는 값은 반드시 return 타입과 일치하거나 자동 형변환이 가능한 타입이어야한다

3) 메소드의 사용 목적
	- 중복된 코드의 제거
	- 높은 재사용성
	- 유지보수에 유리함

4) 메소드 오버로딩(Method Overloading) => 다형성 : 같은 코드로 다른 기능을 하는 것
	Method : 메소드(작업을 수행하는 코드 블록)
	Overloading : 과부화 프로그래밍에서는 같은 이름을 여러번 사용하는 것을 의미

	같은 이름의 메소드를 여러개 정의하는 것을 의미
	★매개변수의 개수, 타입, 순서가 다르면 같은 이름의 메소드로 선언할 수 있다
	반환타입은 오버로딩에 영향을 주지 않는다

- 메소드 오버로딩의 조건
	리턴타입은 같아도 상관없음
	메소드의 이름은 동일해야함
	매개변수의 타입, 개수, 순서가 달라야함

- 메소드 오버로딩의 주의사항
	매개변수의 타입, 개수, 순서가 똑같은 경우 매개변수의 이름이 다르다고 해서 오버로딩이 아니다
	리턴타입만 다르고 메소드의 이름과 매개변수가 동일한 경우에도 오버로딩이 아니다

- 메소드 오버로딩이 필요한 이유?
	- 이름의 통일성 : 비슷한 작업을 수행하는 메소드는 같은 이름을 사용하면 직관적이다
	- 코드 가독성 : 여러 작없을 하나의  이름으로 처리할 수 있어 코드가 간결해진다(메소드이름을 따로 기억할 필요가 없다)

- 메소드 오버로딩이 가능한 이유
	컴파일러가 메소드 호출 시 메소드 이름뿐만 아니라 매개변수의 정보를 사용해 
	정확히 어떤 메소드를 호출할 지 구분하기 때문이다

	컴파일 시 메소드 이름이 다르게 지정됨
		컴파일러는 메소드의 이름과 매개변수의 정보를 합쳐서 고유한 시그니처(Method Signature)를 생성
		시그니처는 메소드이름 + 매개변수의 타입과 개수로 구성

- 컴파일러가 메소드를 선택하는 과정
	매개변수의 개수 확인 : 메소드 호출 시 인수값의 개수와 일치하는 메소드를 먼저 찾는다
	매개변수의 타입 확인 : 메소드 호출 시 전달된 인수값의 타입과 일치하는 메소드를 찾는다
	타입 변환 규칙 적용 : 전달된 인수값의 타입과 완전히 일치하는 메소드가 없을 경우, 더 큰 타입으로 변환가능한
			메소드를 호출(작은 타입의 값은 큰 타입으로 자동형변환이 가능하기 때문)
			int -> long, float, double 순으로 자동변환 가능
			큰 타입이 호출 우선순위의 뒤에 있다
------------------------------------------------------------------------------------------------------

메소드 호출방법 4가지
매개변수	리턴값	메소드 호출
x	x
o	x
x	o
o	o
메소드 오버로딩

배열 선언과 생성
//1차원
//칸수 알 때
   자료형[] 배열명 = new 자료형[칸수];

//값 알 때
   자료형[] 배열명 = {값, 값, ...};

//배열변수만 선언할 때
   자료형[] 배열명 = null;

//선언과 생성을 따로할 때
   자료형[] 배열명;
   배열명 = new 자료형[]{값, ...};

//2차원
//칸수알 때
   자료형[][] 배열명 = new 자료형[행][열];

//값을 알 때
   자료형[][] 배열명 = {{값, 값}, {값, 값}, {값, 값}}; //열이 같을 때
   자료형[][] 배열명 = {{값}, {값, 값}, {값, 값, 값}}; //열이 다를 때


입력받은 숫자까지 총합 구하는 메소드(매개변수o,리턴값o)

//1)리턴타입 void => int
//2) 메소드명 printSum
//3) 매개변수 int num
//4) 구현부 => 총합저장할 변수 선언
//5)		for문(초기식 : int i =1; 조건식 : 매개변수에 전달받은 값많큼; i++{
//6)		총합 += i;}
//7)		return 총합;}
//main{

Scanner sc = new Scanner(System.in);
      int number = sc.nextInt();
      syso(메소드명(number));
 static int printSum(int num){
      int sum = 0;
      for(int i=1; i<=num; i++){
         sum += i;
      }
      return sum;
   }



------------------------------------------------------------------------------------------------------
얕은 복사 => 참조값이 복사(원본과 복사본이 서로 의존적),속도 빠름, 메모리 사용량은 적음, 간단한 객체나 데이터 구조
깊은 복사 => 모든 데이터 복사(원본과 복사본이 서로 독립적), 데이터양에 비례 느려짐, 메모리 사용량이 많음, 데이터 독립성 중요
	배열의 값만 수정

2. call by value와 call by reference
	=> 메소드 호출 시 매개변수를 전달하는 방식
1) call by value(pass by value) : 값에 의한 호출
	값을 복사하여 메소드에 전달하는 방식
	메소드 호출 시 원본값이 복사되므로, 메소드 내부에서 값이 변경되어도 원본에는 영향을 미치지 않음
	
	메소드에 인수가 전달되는 것은 변수의 값 자체
	-메소드 내부에서 값을 변경해도 우너본 변수는 변경되지 않음
	- 기본 데이터 타입에선 사용

2) call by reference(pass by reference) : 참조에 의한 호출
	참조를 전달하여 메소드에 직접 원본 데이터를 조작할 수 있는 방식
	메소드 호출 시 데이터의 주소(참조값)가 전달되므로, 메소드 내부에서 데이터를 변경하면 원본 데이터도 변경
	
	-메소드 내부에서 참조된 객체를 수정하면, 원본 객체도 변경됨
	- C++ 등의 언어에서 지원되며, JAVA는 지원되지 않음


	
	
			기본 데이터 타입				참조타입
전달방식			값 자체를 복사하여 전달			참조값(주소)을 복사하여 전달
원본데이터변경여우		메소드 내부 변경이 우너본에 영향 없음		참조된 객체를 변경하여 원본 객체에도 영향있음
참조값 변경여부		의미없음					참조값 자체를 변경해도 원본 참조값에는 영향 없음

+) JAVA 동작
	JAVA는 항상 Call by Balue로 동작한다
	기본 데이터 타입 : 값 자체가 복사되어 전달
	참조 타입 : 객체의 참조값(주소)이 복사되어 전달되므로 객체 내부의 데이터는 수정할 수 있지만 참조값 자체는
		변경되지 않는다
	* 참조타입의  동작이 Call by Refernce 처럼 보일 수 있지만 실제로는 참조값의 복사(Call by Value)이다

	기본 데이터 타입 : stack 메모리에 값 자체가 저장된다
	참조타입 : stack 메모리에 참조값이 저장되고, 객체 자체는 heap 메모리에 저장

3. jVM 메모리에 변수가 저장되는 위치
	기본자료형 : boolean, byte, short, int, float, double, char
	참조자료형 : 배열, enum, class, interface, 기본형을 제외한 모든 것들 

------------------------------------------------------------------------------------------------------
1. 메소드에 대한 내용을 모두 같이 공유해서 노션에 정리하기(개념 정리)
메소드

2. 3문제 만들기(~메소드)

교통카드 잔액 :?
버스 :?
지하철 : ?
택시 :?

몇번씩 탔고 잔액이 남았다면 얼마 부족하면 잔액이 부족합니다 뜨게하기?






          










































