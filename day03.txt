day03
자료형과 변수 -> 제어문자, 출력메소드, 서식문자 -> 형변환

0. 복습
1) jvm, jre, jdk
	jvm
		운영체제에 맞춰서 java로 만든 프로그램을 실행시켜준다.
	jre
		jvm을 실행한다
		jvm을 실행할 때 필요한 라이브러리 파일 등을 가지고 있다.
	jdk
		jre를 포함한다
		jre외에 개발에 필요한 도구들을 가지고 있다.

2) 자바 소스코드를 쓰기 위한 과정
	자바 프로젝트 > 패키지 > 클래스 > 메소드 > 소스코드

-자바 프로젝트
	하나의 프로그램 단위
	프로그램을 구성하는 것들을 모아둔 폴더

-패키지
	소스파일들의 묶음 단위
	src 폴더 내에 포함되어있다

-클래스
	.java 확장자
	모든 코드는 클래스 내부에 작성된다
	클래스 이름은 반드시 첫문자를 대문자로 작성해야한다
	
-메소드
	메인메소드 : 프로그램이 시작되는 시작점(entry point)
	자바 프로그램이 실행되면 메인 메소드의 코드가 실행된다
	
	출력메소드 : System.out.println()
	소괄호 안에 있는 값을 콘솔창에 출력한다
	
-------------------------------------------------------------------------------------------------------------------
1. 자료형(type) : 값을 종류

	자료형	type	byte	값
	정수형	int	4	양의정수, 음의정수, 0(2, 10, -150, 0, ...)
		long	8	양의정수, 음의정수, 0L(1L, -15L, 0L, ...)
	실수형	double	8	소수점이 있는 수(3.14, 5.2, -15.03, 0.0 ...)		정밀도	15자리
		float	4	소수점이 있는 수(3.14f, 5.2f, -15.03f, 0.0f ...)		6자리
	논리형	boolean 1	true,false
	문자형	char	2	문자 1개('a', 'A', '0', '가',...)
	문자열	String	?	"a", "abc", "김영선", "true",...

bit
	컴퓨터가 처리할 수 있는 최소의 데이터 단위
	0,1

byte
	bit 8개를 묶어서 1byte

문자
	작은 따옴표로 감싸진 1개의 문자

문자열
	문자들의 나열
	큰 따옴표로 감싸진 0개 이상의 문자

2. 변수(Variable)
	어떤 값을 저장하기 위한 저장공간

1) 변수의 특징
	- 변수는 오직 하나의 자료형만 저장할 수 있다
	- 변수는 오직 하나의 값만 저장할 수 있다

	=> 하나의 자료형과 하나의 값만 저장할 수 있는 저장공간이다
	
2) 변수의 선언과 사용
	변수의 선언(만든다)
		자료형 변수명;
		int number;
		boolean isTrue;
		char alpha;
	변수에 값을 저장하는 방법
		변수명 = 값;
		= 대입연산자(오른쪽의 값을 왼쪽에 저장한다, 대입한다)
		
		number = 10; -> 10이라는 값을 number저장공간에 저장한다 라고 해석가능
		isTrue = true;
		alpha = 'a';

	변수의 선언과 동시에 초기화
		자료형 변수명 = 값;
		int number = 100;
		char alpha = 'a';

	여러개의 변수를 선언하는 방법
		int num1 = 10;
		int num2 = 20;
		int num3 = 30;
		int num1 = 10, num2 = 20, num3 = 30;

+) 저장공간과 값
	int num =10;	-> 저장공간
	num = 10 + num;	-> 왼쪽 num 저장공간, 오른쪽 num 값 10
	syso(num);	-> num의 값 : 20

	syso(num + 100);	->출력결과 120
	num = num + 4		->왼쪽 num 저장공간, 오른쪽 num 값 20

3) 변수 선언시 주의사항
	같은 영역에서(중괄호 안) 같은 이름의 변수를 선언할 수 없다
	되도록 소스코드 위쪽에 한꺼번에 선언한다
	되도록 선언과 동시에 초기화를 한다

4) 변수명(저장공간 이름) 주의사항
	문자부터 시작한다
	특수문자를 쓸 수 없다(단, _와 $는 가능)
	공백을 사용할 수없다(카멜표기법, 스네이크 표기법 등을 활용한다)
	키워드(예약어)를 사용할 수 없다
	되도록 소문자로 시작한다(대소문자를 구분한다)
	되도록 의미 있는 단어, 문자를 사용한다
	되도록 한글은 사용하지 않는다

3. 상수(constant)
	한 번 값이 지정되면 변경할 수 없는 데이터를 의미한다
	final 키워드를 사용하여 상수를 정의할 수 있다
	
1) 상수 선언
	final 자료형 상수명 = 값;
	상수명은 대문자로 작성하고 단어가 바뀔 때는 _로 연결한다

2) 상수 사용시 주의사항
	- 이름 작성 규칙
	- 초기화 필수(final 키워드를 사용시 선언과 동시에 초기화 해야한다)
	- 불변성 : 한 번 값이 지정되면 변경할 수 없으므로 값을 유지할 때 주로 사용한다

4. 변수를 사용하는 이유(값을 왜 변수에 저장해서 사용하는가?)
	1.반복되는 값을 쉽게 관리하기 위해서(값을 재사용하기 위해서)
	2.값에 의미를 부여하기 위해서(값에 이름을 붙여준다)
	3.프로그램의 가동성, 유지보수성, 재사용성을 높이기 위해서 

5.메모리
--------
RAM
--------
STACK
HEAP
METHOD

RAM
	int num;
	num이라는 이름의 저장공간이 RAM에 할당된다

주소값
	메모리(RAM)에 저장공간이 할당되면 고유한 값이 주소값이 부여된다

<쉽게 비유>
	RAM : 작업 도구를 올려두는 큰 책상
		프로그램이 실행되는 동안 데이터를 저장하고 사용하는 공간
	변수 : 책상위의  상자
		데이터를 저장하기 위해 RAM에 만든 이름이 붙은 공간
	주소값 : 상자의 위치
		컴퓨터가 RAM에서 변수를 찾을 때 사용하는 고유한 번호

5. 제어문자, 이스케이프문자(Escape Character / Sequence)
	따옴표 안에서 사용되며 미리 예약된 특수한 기능을 하는 문자
	\(백슬래쉬, 역슬래쉬) 를 사용한다
	
	\n : 줄바꿈
	\t : 일정 간격을 띄어준다(tab)
	\" : 문자열안에서 큰따옴표를 표현
	\' : 문자열안에서 작은 따옴표를 표현
	\\ : 문자열안에서

6. 출력메소드
	소괄호안에 있는 내용을 콘솔창에 출력한다
	println()
		전달된 값을 콘솔창에 출력하고 줄바꿈이 된다
	print()
		전달된 값을 콘솔창에 출력하고 줄바꿈이 되지 않는다
	prinf()
		형식(서식 format)에 맞는 콘솔창에 출력하고 줄바꿈이 되지 않는다

1) 출력 메소드의 목적
	개발자가 오류를 해결하기 위해 값을 확인할 때 사용한다
	- 디버깅 : 개발자가 프로그램 중간에 변수값등을 출력하여 오류를 확인하거나 데이터 흐름을 추적
	- 정보전달 : 프로그램의 진행상태나 결과를 알림
	- 형식 지정 출력 : 데이터를 정렬하거나 특정 형식으로 표현

2) printf()
	형식 지정자를 사용하여 데이터를 특정 형식으로 출력할 수 있다
	줄바꿈은 자동으로 이루어지지 않으며 필요하면 \n을 추가해서 사용한다

3) 형식 지정자(서식문자)
	출력 형식을 지정한다
	%로 시작하며 printf()에서만 사용한다
	반드시 따옴표 안에서 작성한다
	, 뒤에 나오는 값이 형식 지정자의 위치로 대입된다(들어가게된다)

	자료형	형식지정자		의미
	int	%d		decimal(10진수 정수)
		%o		octal(8진수 정수)
		%x		haxadecimal(16진수 정수)
	double	%f		float(실수)
	char	%c		character(문자)
	String	%s		String(문자열)

4) 서식문자의 옵션
	%[- or 0][n][.m]서식문자
	-	왼쪽 정렬
	0	비어있는 공간을 0으로 채움(int,double만 가능)
	n	자리수
	.m	소숫점 아래 자리수 / 문자열 자르기

7. 형변환(Type Casting)
	하나의 자료형을 다른 자료형으로 변환하는 과정을 의미한다
	강제 형변환과 자동 형변환 두가지 방식이 있다

1) 강제 형변환
	(자료형) 값

	큰 자료형을 작은 자료형으로 변환할 때 사용된다
	데이터 손실이 발생할 수 있다
	ex) double -> int, long -> int

- 실수 -> 정수		소수점 이하의 값이 버려짐(반올림 되지 않는다)
- 큰 정수 -> 작은 정수	데이터 손실 또는 값 왜곡 발생가능성 있음
-문자 -> 정수		문자를 정수(유니코드 값)으로 변환
-정수 -> 문자		정수를 문자코드 값으로 변환

2) 자동형변환
	작은 크기의 자료형을 큰 크기의  자료형으로 변환할 때 컴파일러가 자동으로 수행한다
	데이터 손실이 없기 때문에 안전하게 변환할 수 있다
	명시적으로 형변환 연산자를 사용하지 않아도 된다

- 작은 자료형에서 큰 자료형으로 변환
- 연산 시 형변환이 이루어질 때 자동변환(더 큰 자료형으로 자동변환)
- 문자형(char)에서 정수형(int)로 변환
- 정수형값을 실수로 변환

3) 문자열 형변환
- 다른 자료형을 문자열로 변환	* ""->문자열을 의미 + -> 연결을 의미 *
	문자열과 다른 자료형을 연결(+)하면 결과는 항상 문자열이 된다

-문자열을 다른 자료형으로 변환	""->문자열을 의미 + -> 연결을 의미
	기본 자료형은 기본자료형끼리만 형변환이 가능하다
	String 클래스 타입(래퍼 타입)
	
	모든 기본 자료형을 담고잇는 클래스 타입이 있고 String을 다른 자료형으로 변환시에는 이 클래스타입의 도움을 받는다
	int -> Integer
	long -> Long
	double -> Double
	float -> Float
	char -> Character
	boolean -> Boolean	

	String data1 = "10";
	String data2 = "abc";
	int result = Integer.parseInt(data1);
	long result2 = Long.parseLong(data1);
	double result3 = Double.parseDouble(data1);	//10.0
	char result4 = "abc".charAt(index번호);	*index번호는 항상 앞은 0부터 시작
----------------------------------------------------------------------------------------------------------------------
복습
	변수 : 값을 저장하는 공간
		자료형 변수명 = 값; // 소문자로 시작, 단어가 바뀔 때 대문자로 변수명 작성
	상수 : 항상 같은 값을 갖는 값
		final 자료형 상수명 = 값; // 대문자와 _로 상수명 작성

	자료형
		정수형	int(4byte), long(8byte)
		실수형	double(8byte), float(4byte)
		논리형	boolean(1byte)	=> true, false
		문자형	char(2byte)	=> 'a'
		문자열	String(?)	=> ""
	
	출력 메소드
		println() 콘솔창에 출력 줄바꿈
		print() 콘솔창에 출력 줄바꿈X
		printf() 
		
		형식지정자 %d, %d, %x, %s, %c, %f

	이스케이프 문자
		\n, \t, \", \', \\

	형변환
		자동형변환
		- 작은 타입의 값을 큰 타입의 저장공간에 저장 가능하다
			int -> double
			int -> long
			float -> double
			char -> int	문자코드
			정수 + 실수 => 실수형
			정수 + 정수 => 정수형
		강제형변환	
		- 큰 타입의 값을 작은 타입의 저장공간에 저장
			double -> float		(float) 값
			double -> int		(int) 값
			long -> int
			//Overflow 원리
		//int의 범위는 32bit 자료형, 값의 범위가 -2.147.483.648 ~ 2,147,483,647이다
		//long에서 int 변환
		//2147483648은 int 범위를 초과하므로 상위 비트(초과된 비트)가 잘리게 된다
		// 잘린 값은 2의 보수 형식으로 계산되며 음수 값으로 변환된다

		다른 타입 -> 문자열로 형변환
			+ ""

		문자열 값 -> 다른 타입 형변환
			클래스 타입을 이용한다
			int -> Integer
			double -> Double
			boolean -> Boolean
			char -> Character
			long -> Long
			float -> Float			*.parse()

		- 인덱스번호 : 문자열의 방 번호, 0부터 시작한다			


























	